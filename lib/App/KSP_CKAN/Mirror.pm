package App::KSP_CKAN::Mirror;

use v5.010;
use strict;
use warnings;
use autodie;
use Method::Signatures 20140224;
use Carp qw( croak );
use List::MoreUtils 'first_index';
use Digest::file qw(digest_file_hex);
use File::chdir;
use File::Basename qw(basename);
use File::Temp qw(tempdir);
use File::Path qw(remove_tree);
use File::Copy qw(copy);
use App::KSP_CKAN::Tools::IA;
use App::KSP_CKAN::Tools::Http;
use App::KSP_CKAN::Metadata::Ckan;
use Moo;
use namespace::clean;

# ABSTRACT: MirrorKAN mirroring service

# VERSION: Generated by DZP::OurPkg:Version

=head1 SYNOPSIS

  use App::KSP_CKAN::Mirror;

  my $mirror = App::KSP_CKAN::Mirror->new(
    config => $config,
  );

=head1 DESCRIPTION

Mirroring abstraction to be used by other libraries.

=cut

my $Ref = sub {
  croak("auth isn't a 'App::KSP_CKAN::Tools::Config' object!") unless $_[0]->DOES("App::KSP_CKAN::Tools::Config");
};

has 'config'      => ( is => 'ro', required => 1, isa => $Ref );
has '_ia'         => ( is => 'ro', lazy => 1, builder => 1 );
has '_http'       => ( is => 'ro', lazy => 1, builder => 1 );

method _build__ia {
  return App::KSP_CKAN::Tools::IA->new(config => $self->config);
}

method _build__http {
  return App::KSP_CKAN::Tools::Http->new();
}

method _tmp_dir {
  return File::Temp::tempdir();
}

method _clean_tmp_dir($tmp) {
  if ( -d $tmp ) {
    remove_tree($tmp);
  }
  return;
}

# TODO: What happens when we load an invalid file?
method _load_ckan($ckanfile) {
  $self->logdie("Ckan file does not exist at '$ckanfile'") unless (-f $ckanfile);
  return App::KSP_CKAN::Metadata::Ckan->new( file => $ckanfile );
}

# TODO: Could use some more logic here, maybe a while loop.
method _check_overload {
  if ( $self->_ia->check_overload ) {
    return 1;
  }
  return 0;
}

method _check_cached($hash) {
  my @files = glob($self->config->cache."/*");
  my $index = first_index { basename($_) =~ /^$hash/i } @files;
  if ( $index != '-1' ) {
    return $files[$index];
  }
  return 0;
}

method _check_file($file,$ckan) {
  my $cached = $self->_check_cached($ckan->url_hash);

  if ( $cached eq 0 ) {
    $self->info("Not found in cache, downloading");
    $self->_http->mirror(
      url   => $ckan->download,
      path  => $file,
    );
  } else {
    $self->info("Download found as $cached");
    copy($cached, $file) or $self->warn("Cache copy failed: $!");
  }

  if ( ! -f $file ) {
    $self->warn("File was not able to be downloaded or copied");
    return 0;
  }

  if ( $ckan->download_sha256 ne uc(digest_file_hex( $file, "SHA-256" )) ) {
    $self->warn("SHA256 of file doesn't match metadata");
    return 0;
  }

  return 1;
}

# TODO: A lot of this logic should be moved into the IA class. We could
#       very easily support multiple mirror backends. Potentially
#       convert IA to a Role, or make this class exntendable with a
#       required attribute of App::KSP_CKAN::Mirror::$Backend
method upload_ckan($ckanfile) {
  my $ckan = $self->_load_ckan($ckanfile);
  $self->logdie("Ckan '".$ckan->mirror_item."' cannot be mirrored") unless $ckan->can_mirror;
  my $tmp = $self->_tmp_dir;
  my $file = $tmp."/".$ckan->mirror_filename;
 
  if ( $self->_check_overload ) {
    # Let's clean ourselves up first.
    $self->_clean_tmp_dir($tmp);
    $self->warn("The Internet Archive is overloaded, try again later");
    return 0;
  }
  
  if ( $self->_ia->ckan_mirrored( ckan => $ckan ) ) {
    $self->info($ckan->mirror_item." Already has a file mirrrored with the SHA1 hash of ".$ckan->download_sha1);
    return 1;
  }
  
  my $result = 0;
  
  if ( $self->_check_file( $file, $ckan ) ) {
    $result = $self->_ia->put_ckan(
      ckan => $ckan,
      file => $file,
    );
  }
  
  if ( $result ) {
    $self->info($ckan->mirror_item." mirrored to the Internet Archive successfully @ ".$ckan->mirror_url);
    return 1;
  }
  
  # TODO: This needs a test, we weren't cleaning our temp files.
  $self->_clean_tmp_dir($tmp);
  $self->warn($ckan->mirror_item." failed to mirror to the Internet Archive");
  return 0;
}

with('App::KSP_CKAN::Roles::Logger');

1;
