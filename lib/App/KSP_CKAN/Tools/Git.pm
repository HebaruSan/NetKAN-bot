package App::KSP_CKAN::Tools::Git;

use v5.010;
use strict;
use warnings;
use autodie qw(:all);
use Method::Signatures 20140224;
use Carp qw(croak);
use Try::Tiny;
use Git::Wrapper;
use Capture::Tiny qw(capture capture_stdout);
use File::chdir;
use File::Path qw(remove_tree mkpath);
use Moo;
use namespace::clean;

# ABSTRACT: A collection of our regular git commands

# VERSION: Generated by DZP::OurPkg:Version

=head1 SYNOPSIS

  use App::KSP_CKAN::Git;

  my $git = App::KSP_CKAN::Git->new(
    remote => 'git@github.com:KSP-CKAN/NetKAN-bot.git',
    local => "$ENV{HOME}/.NetKAN/NetKAN-bot",
    clean => 1,
  );

=head1 DESCRIPTION

CKAN's development + build process is built around git. The
things we need to do are pretty common and all git 
interactions will fit nicely here.

The wrapper can be called with the following options.

=over

=item remote

Remote repository path or url.

=item local

Path to the working directory of where it will be cloned.

=item working

This optional, we'll try to guess that. It can however
be provided (just the human name, no slashes).

=item clean

Will remove and pull a fresh copy of the repository.

=item shallow

Will perform a shallow clone of the repository

=back

=cut

has 'remote'    => ( is => 'ro', required => 1 );
has 'local'     => ( is => 'ro', required => 1 );
has 'working'   => ( is => 'ro', lazy => 1, builder => 1 );
has 'clean'     => ( is => 'ro', default => sub { 0 } );
has 'shallow'   => ( is => 'ro', default => sub { 1 } );
has 'branch'    => ( is => 'rw', lazy => 1, builder => 1 );
has '_git'      => ( is => 'rw', isa => sub { "Git::Wrapper" }, lazy => 1, builder => 1 );

method _build__git {
  if ( ! -d $self->local ) {
    mkpath($self->local);
  }

  if ( ! -d $self->local."/".$self->working ) {
    $self->_clone;
  }

  if ($self->clean) {
    $self->_clean;
  }

  return Git::Wrapper->new({
    dir => $self->local."/".$self->working,
  });
}

method _build_working {
  $self->remote =~ m/^(?:.*\/)?(.+)$/;
  my $working = $1;
  $working =~ s/\.git$//;
  return $working;
}

method _clone {
  # TODO: I think Git::Wrapper has a way to do this natively
  # TODO: We should pass back success or failure.
  if ($self->shallow) {
    capture { system("git", "clone", "--depth", "1", $self->remote, $self->local."/".$self->working) };
  } else {
    capture { system("git", "clone", $self->remote, $self->local."/".$self->working) };
  }
  return;
}

method _clean {
  # TODO: We could fail here too, we should return as such.
  # NOTE: We've not instantiated a git object at this point, so
  # we can't use it.
  local $CWD = $self->local."/".$self->working;
  capture { system("git", "reset", "--hard", "HEAD") };
  capture { system("git", "clean", "-df") };

}

method _build_branch {
  my @parse = $self->_git->rev_parse(qw|--abbrev-ref HEAD|);
  return $parse[0];
}

=method add_all

  $git->add;

This method will perform a 'git add .' 

=cut

# TODO: It'd probably be nice to allow a list of 
# files
method add($file?) {
  if ($file) {
    $self->_git->add($file);
  } else {
    $self->_git->add(".");
  }
  return;
}

=method changed
  
  my @changed = $git->changed;

Will return a list of changed files when compared to 
origin/current_branch. Can be used in scalar context 
(number of committed files) or an if block.

  if ($git->changed) {
    say "We've got changed files!";
  }

Takes an optional bool parameter of 'origin' if you want
a list of comparing local.

  my @local = $git->changed( origin => 0 );

=cut

method changed(:$origin = 1) {
  if ( $origin ) {
    return $self->_git->diff({ 'name-only' => 1, }, "--stat", "origin/".$self->branch );
  } else {
    return $self->_git->diff({ 'name-only' => 1, });
  }
}

=method commit

  $git->commit( all => 1, message => "Commit Message!" );

Will commit all staged added files with a generic
commit message.

=over

=item all

Optional argument. Defaults to false.

=item file

Optional argument. Will commit all if not provided.

=item message

Optional argument. Will literally add 'Generic Commit' as
the commit message if not provided.

=back

=cut

method commit(:$all = 0, :$file = 0, :$message = "Generic Commit") {
  if ($all || ! $file) {
    return $self->_git->commit({ a => 1 }, "-m $message");
  } else {
    return $self->_git->commit($file, "-m \"$message\"");
  }
}

=method checkout_branch

  $git->checkout_branch("staging")

Checks out the destination branch if it exists else creates it and
checks it out.

=cut

method checkout_branch($branch) {
  local $CWD = $self->local."/".$self->working;
  capture { system("git checkout $branch 2>/dev/null || git checkout -b $branch") };
}

=method cherry_pick

  $git->cherry_pick($commit);

Cherry picks a commit into the current branch.

=cut

method cherry_pick($commit) {
  $self->_git->RUN("cherry-pick", $commit);
  return;
}

=method staged_commit

  $git->staged_commit( 
    file        => "/path/to/ExampleNetKAN.netkan",
    identifier  => "ExampleNetKAN", 
    message     => "NetKAN bot loves to commit!",
  );

Performs a commit to the staging branch, then checks out an identifier
branch and cherry-picks the commit from the previous commit to staging.

=cut

# TODO: The staging branch is will reflect the first point it branched
#       from master on the NetKAN bot. So to use the staging branch
#       it must accompany the primary repository in ckan. It'll worth
#       seeing how this works in practice and think on how to solve
#       them drifting.

method staged_commit(:$identifier, :$file, :$message = "Generic Commit") {
  # NOTE: Not 100% happy with this line, but if our branch value isn't
  #       populated we'll end up stuck on the last identifier that was 
  #       checked out.
  $self->branch;

  # Commit to staging branch
  $self->checkout_branch("staging");
  $self->pull( ours => 1 );
  $self->commit(
    file    => $file,
    message => $message,
  );
  $self->_git->push("origin","staging");
 
  # Get the commit ID of the staged CKAN 
  my $commit = $self->last_commit;
  
  # NOTE: We need to go back to our original branch to avoid
  #       diverging from our staging branch
  $self->checkout_branch($self->branch);

  # Commit to identifier branch
  $self->checkout_branch($identifier);
  $self->pull( ours => 1 );
  $self->cherry_pick($commit);
  $self->_git->push("origin",$identifier);

  # Return to our original branch
  $self->checkout_branch($self->branch);
  return;
}

=method reset
  
  $git->reset( file => $file );

Will reset the uncommitted file.

=cut

# TODO: We can likely expand what we can do with reset.
method reset(:$file) {
  return $self->_git->RUN("reset", $file);
}

=method push
  
  $git->push;

Will push the local branch to origin/branh.

=cut

method push {
  return $self->_git->push("origin",$self->branch);
}

=method pull

  $git->pull;

Performs a git pull. Takes optional bool arguments of
'ours' and 'theirs' which will tell git who wins when
merge conflicts arise.

=cut

method pull(:$ours?,:$theirs?) {
  if ($theirs) {
    $self->_git->pull(qw|-X theirs|);
  } elsif ($ours) {
    $self->_git->pull(qw|-X ours|);
  } else {
    $self->_git->pull;
  }
  return;
}

=method last_commit
  
  $git->last_commit;

Will return the full hash of the last commit.

=cut

method last_commit {
  # NOTE: We could have used the builtin $git->RUN('log', '--format=%H'))[0],
  #       but it parses the entire commit history which at ~19000 commits
  #       takes about 120ms, this takes less than 2ms.
  local $CWD = $self->local."/".$self->working;
  my $commit = capture_stdout { system("git", "log", "--no-patch", "HEAD^..HEAD", '--format=%H') };
  chomp($commit);
  return $commit;
}

=method yesterdays_diff

  $git->yesterdays_diff;

Produces a list of files of changes since yesterday.

git diff $(git rev-list -n1 --before="yesterday" master) --name-only

=cut

# TODO: It'd be cool to be able to test this
method yesterdays_diff {
  my $branch = $self->branch;
  local $CWD = $self->local."/".$self->working;
  my $changed = capture_stdout { system("git diff \$(git rev-list -n1 --before=\"yesterday\" $branch) --name-only") };
  chomp $changed;
  return split("\n", $changed);
}

1;
